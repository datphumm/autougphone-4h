# -*- coding: utf-8 -*-
import os, zipfile, tempfile, json, sys, time, re, queue, threading, concurrent.futures, shutil, hashlib, traceback
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog, simpledialog

import requests
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException

# ================== C·∫§U H√åNH M·∫∂C ƒê·ªäNH ==================
UG_REGISTER_URL = "https://www.ugphone.com/toc-portal/#/login"
CHECK_IP_URL    = "https://ipx.ac/"

EMAIL_TYPE_DELAY = 0.06
PASS_TYPE_DELAY  = 0.055
POST_CLICK_PAUSE = 0.5

PROXY_RESET_COOLDOWN = 60
PROXY_POST_RESET_BUFFER = 3  # gi√¢y
# ============================================================================

UA_POOL = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_4_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
]
def pick_user_agent(email: str, idx: int) -> str:
    h = int(hashlib.sha256((email + str(idx)).encode()).hexdigest(), 16)
    return UA_POOL[h % len(UA_POOL)]

# ================== KH√ìA THEO C·ªîNG PROXY ==================
PROXY_LOCKS = {}
PROXY_LOCKS_LOCK = threading.Lock()
def _proxy_key(proxy_conf: dict) -> str:
    if not proxy_conf: return "NO_PROXY"
    scheme = proxy_conf.get("scheme", "http")
    host   = proxy_conf.get("host", "")
    port   = proxy_conf.get("port", 0)
    user   = proxy_conf.get("user", "")
    return f"{scheme}://{user}@{host}:{port}"
def acquire_proxy_lock(proxy_conf: dict):
    key = _proxy_key(proxy_conf)
    with PROXY_LOCKS_LOCK:
        lock = PROXY_LOCKS.get(key)
        if lock is None:
            lock = threading.Lock()
            PROXY_LOCKS[key] = lock
    lock.acquire()
    return key, lock
def release_proxy_lock(key: str):
    with PROXY_LOCKS_LOCK:
        lock = PROXY_LOCKS.get(key)
    if lock and lock.locked():
        lock.release()

# ================== PROXY EXTENSION (n·∫øu c·∫ßn auth) ==================
def create_proxy_auth_extension_mv3(host, port, user, pwd, scheme="http"):
    manifest = {
        "name": "ProxyAuth MV3 (temp)",
        "version": "1.0.0",
        "manifest_version": 3,
        "permissions": ["proxy", "storage", "webRequest", "webRequestBlocking"],
        "host_permissions": ["<all_urls>"],
        "background": {"service_worker": "sw.js"},
        "minimum_chrome_version": "88.0.0"
    }
    sw_js = f"""
const config = {{
  mode: "fixed_servers",
  rules: {{
    singleProxy: {{ scheme: "{scheme}", host: "{host}", port: {int(port)} }},
    bypassList: ["localhost","127.0.0.1"]
  }}
}};
chrome.proxy.settings.set({{ value: config, scope: "regular" }}, () => {{}});
function onAuth(details) {{
  return {{ authCredentials: {{ username: "{user}", password: "{pwd}" }} }};
}}
chrome.webRequest.onAuthRequired.addListener(onAuth, {{ urls: ["<all_urls>"] }}, ["blocking"]);
"""
    tmpdir = tempfile.mkdtemp(prefix="proxy_mv3_")
    mf = os.path.join(tmpdir, "manifest.json")
    sw = os.path.join(tmpdir, "sw.js")
    with open(mf, "w", encoding="utf-8") as f:
        json.dump(manifest, f, ensure_ascii=False, indent=2)
    with open(sw, "w", encoding="utf-8") as f:
        f.write(sw_js)
    zip_path = os.path.join(tmpdir, "proxy_auth_mv3.zip")
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
        z.write(mf, "manifest.json"); z.write(sw, "sw.js")
    return zip_path, tmpdir

# ================== DRIVER ==================
from selenium.webdriver.common.keys import Keys
def build_driver(use_proxy: bool, proxy_conf: dict, win_w: int, win_h: int,
                 pos_x: int = 0, pos_y: int = 0,
                 user_agent: str = None,
                 user_data_dir: str = None,
                 headless: bool = False):
    chrome_opts = Options()
    if headless:
        chrome_opts.add_argument("--headless=new")
        chrome_opts.add_argument("--window-size=1920,1080")
    chrome_opts.add_argument("--no-first-run")
    chrome_opts.add_argument("--no-default-browser-check")
    chrome_opts.add_argument("--disable-background-networking")
    chrome_opts.add_argument("--disable-dev-shm-usage")
    chrome_opts.add_argument("--disable-gpu")
    chrome_opts.add_argument("--force-webrtc-ip-handling-policy=disable_non_proxied_udp")
    chrome_opts.add_argument("--no-sandbox")
    chrome_opts.add_argument("--disable-browser-side-navigation")
    chrome_opts.add_argument("--log-level=3")
    chrome_opts.add_argument("--disable-quic")
    chrome_opts.add_argument("--disable-http2")
    chrome_opts.add_argument("--disable-features=OptimizationHints,NetworkServiceInProcess")
    chrome_opts.add_argument("--enable-features=NetworkService")

    chrome_opts.add_experimental_option("detach", False)
    chrome_opts.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_opts.add_experimental_option("useAutomationExtension", False)
    if not headless:
        chrome_opts.add_argument(f"--window-size={int(win_w)},{int(win_h)}")
        chrome_opts.add_argument(f"--window-position={int(pos_x)},{int(pos_y)}")
    chrome_opts.page_load_strategy = "eager"

    if user_data_dir:
        chrome_opts.add_argument(f"--user-data-dir={user_data_dir}")
    chrome_opts.add_argument("--disk-cache-size=1")
    chrome_opts.add_argument("--media-cache-size=1")
    if user_agent:
        chrome_opts.add_argument(f"--user-agent={user_agent}")
    if use_proxy and proxy_conf:
        scheme = proxy_conf.get("scheme","http")
        host   = proxy_conf.get("host","")
        port   = int(proxy_conf.get("port",0))
        user   = proxy_conf.get("user","")
        pwd    = proxy_conf.get("pass","")
        if user and pwd:
            ext_zip, _ = create_proxy_auth_extension_mv3(host, port, user, pwd, scheme)
            chrome_opts.add_extension(ext_zip)
        else:
            chrome_opts.add_argument(f"--proxy-server={scheme}://{host}:{port}")

    service = ChromeService(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=chrome_opts)
    try:
        driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
            "source": "Object.defineProperty(navigator,'webdriver',{get:()=>undefined});"
        })
    except Exception:
        pass
    return driver

# ========= Helpers =========
def slow_type(element, text, delay=0.25):
    for ch in text:
        element.send_keys(ch); time.sleep(delay)

def scroll_into_view(driver, el):
    driver.execute_script("arguments[0].scrollIntoView({behavior:'smooth',block:'center'});", el); time.sleep(0.2)

def safe_click(driver, el):
    try:
        scroll_into_view(driver, el); el.click(); time.sleep(POST_CLICK_PAUSE); return True
    except Exception:
        try:
            driver.execute_script("arguments[0].click();", el); time.sleep(POST_CLICK_PAUSE); return True
        except Exception:
            return False

def parse_email_pass(line: str):
    if '|' not in line: raise ValueError("Sai ƒë·ªãnh d·∫°ng. D√πng 'email|pass'")
    email, pwd = line.split('|', 1); email=email.strip(); pwd=pwd.strip()
    if not email or not pwd: raise ValueError("Thi·∫øu email ho·∫∑c m·∫≠t kh·∫©u.")
    return email, pwd

def parse_proxy_string(proxy_line: str):
    parts = proxy_line.strip().split(':')
    if len(parts) == 4:
        host, port, user, pwd = parts
        return {"host": host, "port": int(port), "user": user, "pass": pwd, "scheme": "http"}
    elif len(parts) == 2:
        host, port = parts
        return {"host": host, "port": int(port), "user": "", "pass": "", "scheme": "http"}
    else:
        raise ValueError(f"ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá: '{proxy_line}'. D√πng 'host:port:user:pass' ho·∫∑c 'host:port'.")

def first_visible(driver, by, value, timeout=25):
    wait = WebDriverWait(driver, timeout)
    wait.until(EC.presence_of_all_elements_located((by, value)))
    for el in driver.find_elements(by, value):
        try:
            if el.is_displayed() and el.is_enabled(): return el
        except Exception:
            continue
    return wait.until(EC.visibility_of_element_located((by, value)))

def current_url_safe(driver) -> str:
    try:
        return driver.current_url or ""
    except Exception:
        return ""

# ========= Robust wrappers =========
TRY_RESET_ERRORS = (WebDriverException,)
def _looks_like_conn_reset(e: Exception) -> bool:
    s = str(e)
    return ("ConnectionResetError(10054" in s) or ("10054" in s) or ("ProtocolError" in s) or ("Failed to check if window was closed" in s)
def robust_call(call_fn, *, attempts=3, sleep_sec=1.5, log_fn=print, what="driver call"):
    first_trace_dumped = False
    for i in range(1, attempts + 1):
        try:
            res = call_fn()
            return True, res
        except TRY_RESET_ERRORS as e:
            if _looks_like_conn_reset(e):
                if not first_trace_dumped:
                    log_fn(f"[ROBUST] {what}: k·∫øt n·ªëi reset. Th·ª≠ l·∫°i {i}/{attempts}.\n" + traceback.format_exc())
                    first_trace_dumped = True
                else:
                    log_fn(f"[ROBUST] {what}: reset, retry {i}/{attempts}‚Ä¶")
                time.sleep(sleep_sec)
                continue
            return False, e
        except Exception as e:
            return False, e
    return False, RuntimeError(f"{what} th·∫•t b·∫°i sau {attempts} l·∫ßn th·ª≠")

# ================== LocalStorage VERIFY + EXPORT ==================
def get_localstorage_json(driver) -> dict:
    try:
        raw = driver.execute_script("return JSON.stringify(window.localStorage);")
        if not raw:
            return {}
        data = json.loads(raw)
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}

def has_ugphone_session(ls: dict) -> bool:
    tok = (ls.get("UGPHONE-Token") or "").strip()
    has_id = bool((ls.get("UGPHONE-ID") or "").strip())
    has_mqtt = bool((ls.get("UGPHONE-MQTT") or "").strip())
    if tok and not tok.lower().startswith("visitor-"):
        return True
    if tok and (has_id or has_mqtt):
        return True
    return False

def sanitize_filename(s: str) -> str:
    s = re.sub(r'[^a-zA-Z0-9._-]+', '_', s)
    return s.strip('_') or "account"

def export_localstorage_to_file(ls: dict, export_dir: str, email: str, log_fn=print):
    try:
        if not export_dir:
            log_fn("[EXPORT] B·ªè qua: ch∆∞a ch·ªçn th∆∞ m·ª•c l∆∞u.")
            return
        os.makedirs(export_dir, exist_ok=True)
        base = email.replace('@', '_at_').replace(':', '_')
        fname = sanitize_filename(base) + ".txt"
        path = os.path.join(export_dir, fname)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(ls, f, ensure_ascii=False, indent=2, sort_keys=True)
        log_fn(f"[EXPORT] ƒê√£ l∆∞u localStorage ‚Üí {path}")
    except Exception as e:
        log_fn(f"[EXPORT] L·ªói l∆∞u localStorage: {e}")

# ================== Reset IP (Generic API) ==================
def reset_ip_via_api(reset_url, log_fn=print):
    if not reset_url:
        log_fn("[RESET] Kh√¥ng c√≥ URL reset -> b·ªè qua.")
        return False, None, 0
    try:
        log_fn(f"[RESET] ƒêang g·ªçi API: {reset_url}")
        r = requests.get(reset_url, timeout=20)
        log_fn(f"[RESET] API Response (Code: {r.status_code}): {r.text[:500]}")

        if not r.ok:
            log_fn(f"[RESET] ‚ùå Th·∫•t b·∫°i (HTTP Status: {r.status_code})")
            try:
                data = r.json()
                if str(data.get("code")) == "499":
                    remaining = int(data.get("data", {}).get("remaining_time", 0))
                    log_fn(f"[RESET] ‚è≥ API (mproxy-style) y√™u c·∫ßu ch·ªù {remaining}s.")
                    return False, None, max(remaining, 1)
            except Exception:
                pass
            return False, None, 0

        response_text_lower = r.text.strip().lower()
        if "ok" in response_text_lower or "success" in response_text_lower or "th√†nh c√¥ng" in response_text_lower:
            log_fn(f"[RESET] ‚úÖ Th√†nh c√¥ng (API response text ch·ª©a t·ª´ kh√≥a th√†nh c√¥ng)")
            return True, {"response": r.text.strip()}, 0

        try:
            data = r.json()
            status_val = str(data.get("status", "")).lower()
            success_val = data.get("success")
            code_val = str(data.get("code", "")).lower()
            message_val = str(data.get("message", "")).lower()

            is_success = (
                status_val in ["ok", "success", "true", "1", "200"] or
                success_val is True or
                code_val in ["ok", "success", "true", "1", "200"] or
                "success" in message_val or
                "th√†nh c√¥ng" in message_val
            )

            if is_success:
                log_fn(f"[RESET] ‚úÖ Th√†nh c√¥ng (API JSON response h·ª£p l·ªá).")
                return True, data, 0
            else:
                if code_val == "499":
                    remaining = int(data.get("data", {}).get("remaining_time", 0))
                    log_fn(f"[RESET] ‚è≥ API (mproxy-style) y√™u c·∫ßu ch·ªù {remaining}s.")
                    return False, None, max(remaining, 1)
                
                log_fn(f"[RESET] ‚ùå Th·∫•t b·∫°i (API tr·∫£ v·ªÅ JSON kh√¥ng b√°o th√†nh c√¥ng)")
                return False, None, 0
        except json.JSONDecodeError:
            log_fn(f"[RESET] ‚úÖ Th√†nh c√¥ng (API tr·∫£ v·ªÅ HTTP 200, n·ªôi dung kh√¥ng ph·∫£i JSON, gi·∫£ ƒë·ªãnh l√† OK).")
            return True, {"response": r.text.strip()}, 0

    except requests.exceptions.RequestException as e:
        log_fn(f"[RESET] ‚ùå L·ªói k·∫øt n·ªëi khi g·ªçi API: {e}")
        return False, None, 0
    except Exception as e:
        log_fn(f"[RESET] ‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi reset IP: {e}")
        return False, None, 0

def reset_ip_until_success(reset_url, min_delay, log_fn=print, max_tries=9999):
    tries = 0
    while tries < max_tries:
        tries += 1
        ok, info, wait_seconds_api = reset_ip_via_api(reset_url, log_fn)
        if ok:
            log_fn(f"[RESET] OK sau {tries} l·∫ßn th·ª≠."); return True, info
        final_wait = max(wait_seconds_api, min_delay)
        if final_wait > 0:
            log_fn(f"[RESET] Ch·ªù {final_wait}s tr∆∞·ªõc khi th·ª≠ l·∫°i...")
            time.sleep(final_wait)
        else:
            time.sleep(3)
    return False, None

def ensure_proxy_reset_before_attempt(reset_url: str, last_reset_ts: list, min_delay: int, log_fn=print, post_reset_buffer: int = PROXY_POST_RESET_BUFFER) -> bool:
    if not reset_url:
        return True
    now = time.time()
    last_reset = last_reset_ts[0] or 0
    elapsed = now - last_reset
    if elapsed < PROXY_RESET_COOLDOWN:
        wait_duration = PROXY_RESET_COOLDOWN - elapsed
        if wait_duration > 0:
            log_fn(f"[RESET] ƒêang ƒë·ª£i cooldown {int(wait_duration)}s...")
            time.sleep(wait_duration)
    ok, _ = reset_ip_until_success(reset_url, min_delay, log_fn)
    if not ok:
        log_fn("[RESET] ‚õî Reset IP th·∫•t b·∫°i, kh√¥ng m·ªü tr√¨nh duy·ªát.")
        return False
    last_reset_ts[0] = time.time()
    log_fn(f"[RESET] ‚úÖ Reset IP th√†nh c√¥ng. Ch·ªù ƒë·ªám {post_reset_buffer}s...")
    time.sleep(max(0, int(post_reset_buffer)))
    return True

# ================== Click Google TR√äN TRANG ƒêƒÇNG K√ù ==================
def click_register_google_button(driver: webdriver.Chrome, timeout=25):
    wait = WebDriverWait(driver, timeout)
    xpaths = [
        "//span[contains(normalize-space(),'Ti·∫øp t·ª•c s·ª≠ d·ª•ng d·ªãch v·ª• b·∫±ng Google')]/ancestor::button",
        "//button[.//span[contains(normalize-space(),'Ti·∫øp t·ª•c s·ª≠ d·ª•ng d·ªãch v·ª• b·∫±ng Google')]]",
        "//span[contains(@class,'nsm7Bb-HzV7m-LgbsSe-BPrWId') and contains(normalize-space(),'Google')]/ancestor::*[self::button or self::div][1]"
    ]
    for xp in xpaths:
        try:
            btn = wait.until(EC.element_to_be_clickable((By.XPATH, xp)))
            if safe_click(driver, btn): return True
        except (TimeoutException, WebDriverException):
            pass
    try:
        iframe = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "iframe[src*='accounts.google.com/gsi/button'], iframe[title*='Google']")))
        driver.switch_to.frame(iframe)
        try:
            btn = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "div[role='button'], button, .nsm7Bb-HzV7m-LgbsSe")))
            safe_click(driver, btn); return True
        finally:
            try: driver.switch_to.default_content()
            except Exception: pass
    except (TimeoutException, WebDriverException):
        pass
    css_list = ["button.google-btn", "#google-btn", "button .btn-content", "button.van-button--block"]
    for css in css_list:
        try:
            btn = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, css)))
            if safe_click(driver, btn): return True
        except (TimeoutException, WebDriverException):
            pass
    return False

# ================== Google flow ==================
def login_google_flow(driver: webdriver.Chrome, email: str, password: str):
    wait = WebDriverWait(driver, 50)
    try: driver.switch_to.default_content()
    except Exception: pass
    time.sleep(1.0)
    base = driver.current_window_handle
    for h in driver.window_handles:
        if h != base:
            driver.switch_to.window(h); break
    try:
        wait.until(lambda d: ("accounts.google." in (d.current_url or "")) or ("signin" in (d.current_url or "")))
    except TimeoutException:
        return ("FedCM/popup: c·∫ßn thao t√°c tay.", False)

    # email
    try:
        email_input = first_visible(driver, By.ID, "identifierId", timeout=25)
        scroll_into_view(driver, email_input)
        try: email_input.click()
        except Exception: driver.execute_script("arguments[0].focus();", email_input)
        email_input.clear()
        slow_type(email_input, email, delay=EMAIL_TYPE_DELAY)
        time.sleep(0.2)
        next_btn = first_visible(driver, By.ID, "identifierNext", timeout=15)
        safe_click(driver, next_btn)
    except Exception:
        pass

    # password
    try:
        wait.until(EC.any_of(
            EC.presence_of_element_located((By.NAME, "Passwd")),
            EC.presence_of_element_located((By.CSS_SELECTOR, "input[name='Passwd']"))
        ))
        time.sleep(0.2)
        pwd_input = first_visible(driver, By.CSS_SELECTOR, "input[name='Passwd']", timeout=25)
        scroll_into_view(driver, pwd_input)
        try: pwd_input.click()
        except Exception: driver.execute_script("arguments[0].focus();", pwd_input)
        pwd_input.clear()
        slow_type(pwd_input, password, delay=PASS_TYPE_DELAY)
    except Exception:
        pass

    try:
        next_btn2 = first_visible(driver, By.ID, "passwordNext", timeout=20)
        safe_click(driver, next_btn2)
    except Exception:
        pass

    # confirm/continue n·∫øu c√≥
    for xp in [
        (By.CSS_SELECTOR, "#confirm, input#confirm"),
        (By.XPATH, "//span[normalize-space()='Continue' or normalize-space()='Ti·∫øp t·ª•c' or contains(.,'Continue')]")
    ]:
        try:
            btn = WebDriverWait(driver, 12).until(EC.element_to_be_clickable(xp))
            safe_click(driver, btn)
        except Exception:
            pass

    return ("ƒê√£ x·ª≠ l√Ω ƒëƒÉng nh·∫≠p Google.", True)

# ================== Worker: M·ªñI T√ÄI KHO·∫¢N CH·ªà CH·∫†Y 1 L·∫¶N ==================
def run_flow_single(ep_line: str, proxy_line: str, open_ip_check: bool,
                    win_w: int, win_h: int, pos_x: int, pos_y: int, idx: int,
                    reset_url: str, min_reset_delay: int,
                    log_fn, 
                    headless: bool, stop_event: threading.Event,
                    export_ls_enabled: bool, export_dir: str,
                    ui_update_q: queue.Queue, item_id: str,
                    active_drivers_dict: dict, driver_lock: threading.Lock):
    
    try:
        email, password = parse_email_pass(ep_line)
    except Exception as e:
        log_fn(f"[INPUT] '{ep_line}': Sai 'email|pass'. B·ªé. L·ªói: {e}")
        ui_update_q.put(("status", item_id, "L·ªói Input"))
        return

    proxy_conf = {}
    proxy_key = None
    proxy_lock = None
    driver = None 
    user_data_dir = tempfile.mkdtemp(prefix=f"profile_{re.sub(r'[^a-zA-Z0-9]', '_', email)}_")

    if bool(proxy_line):
        try:
            proxy_conf = parse_proxy_string(proxy_line)
        except ValueError as e:
            log_fn(f"[{email}] ‚ùå Proxy kh√¥ng h·ª£p l·ªá: {e}.")
            ui_update_q.put(("status", item_id, "L·ªói Proxy"))
            shutil.rmtree(user_data_dir, ignore_errors=True)
            return

    if stop_event.is_set(): 
        ui_update_q.put(("status", item_id, "ƒê√£ d·ª´ng"))
        shutil.rmtree(user_data_dir, ignore_errors=True)
        return

    if proxy_conf:
        proxy_key, proxy_lock = acquire_proxy_lock(proxy_conf)
        log_fn(f"[{email}] üîê Gi·ªØ c·ªïng proxy: {proxy_key}")
    
    try:
        # Build driver and perform actions
        try:
            last_reset_ts = [None]
            if reset_url:
                if stop_event.is_set(): return
                if not ensure_proxy_reset_before_attempt(reset_url, last_reset_ts, min_reset_delay, log_fn):
                    raise RuntimeError("Reset IP th·∫•t b·∫°i.")

            if stop_event.is_set(): return
            log_fn(f"[{email}] üîÑ B·∫Øt ƒë·∫ßu ƒëƒÉng nh·∫≠p...")
            ua = pick_user_agent(email, idx)
            
            driver = build_driver(bool(proxy_conf), proxy_conf, win_w, win_h,
                                  pos_x=pos_x, pos_y=pos_y,
                                  user_agent=ua, user_data_dir=user_data_dir,
                                  headless=headless)
            
            with driver_lock:
                if stop_event.is_set(): raise RuntimeError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi g√°n driver")
                active_drivers_dict[item_id] = driver

            if open_ip_check:
                if stop_event.is_set(): return
                driver.get(CHECK_IP_URL)
                try: driver.execute_script(f"document.title = 'IP Check - {email}';")
                except: pass
                time.sleep(1.0)
            
            if stop_event.is_set(): return
            driver.get(UG_REGISTER_URL)
            try: driver.execute_script(f"document.title = 'Login - {email}';")
            except: pass
            
            if stop_event.is_set(): return
            if not click_register_google_button(driver, timeout=30):
                raise RuntimeError("Kh√¥ng click ƒë∆∞·ª£c n√∫t Google")
            
            if stop_event.is_set(): return
            login_google_flow(driver, email, password)

            if stop_event.is_set(): return
            log_fn(f"[{email}] ‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng. Gi·ªØ tr√¨nh duy·ªát m·ªü.")
            ui_update_q.put(("status", item_id, "ƒêang m·ªü"))
            ui_update_q.put(("action", item_id, "ƒê√≥ng"))

            if export_ls_enabled:
                ls = get_localstorage_json(driver)
                if has_ugphone_session(ls):
                    export_localstorage_to_file(ls, export_dir, email, log_fn)
                else:
                    log_fn(f"[{email}] [EXPORT] B·ªè qua, kh√¥ng t√¨m th·∫•y session.")
            
            # Wait for browser to be closed
            while not stop_event.is_set():
                try:
                    if not driver.window_handles:
                        log_fn(f"[{email}] Tr√¨nh duy·ªát ƒë√£ ƒë∆∞·ª£c ƒë√≥ng th·ªß c√¥ng.")
                        ui_update_q.put(("status", item_id, "Ho√†n t·∫•t"))
                        driver = None # Prevent finally block from quitting again
                        return
                except WebDriverException:
                    log_fn(f"[{email}] M·∫•t k·∫øt n·ªëi t·ªõi tr√¨nh duy·ªát (ƒë√£ ƒë√≥ng).")
                    if stop_event.is_set():
                        ui_update_q.put(("status", item_id, "ƒê√£ ƒë√≥ng"))
                    else:
                        ui_update_q.put(("status", item_id, "L·ªói tr√¨nh duy·ªát"))
                    driver = None # Prevent finally block from quitting again
                    return
                time.sleep(1)

            # If we reach here, stop_event was set
            log_fn(f"[{email}] Nh·∫≠n l·ªánh d·ª´ng, lu·ªìng k·∫øt th√∫c.")
            ui_update_q.put(("status", item_id, "ƒê√£ ƒë√≥ng"))

        except Exception as e:
            if not stop_event.is_set():
                log_fn(f"[{email}] ‚ùå L·ªói trong flow: {e}")
                ui_update_q.put(("status", item_id, "L·ªói"))
            else:
                log_fn(f"[{email}] ƒê√£ d·ª´ng trong l√∫c ch·∫°y.")
                ui_update_q.put(("status", item_id, "ƒê√£ d·ª´ng"))
        finally:
            # This block cleans up the driver if it still exists
            with driver_lock:
                active_drivers_dict.pop(item_id, None)
            if driver:
                try: driver.quit()
                except: pass

    finally:
        # This block cleans up non-driver resources
        if proxy_conf and proxy_lock:
            release_proxy_lock(proxy_key)
        shutil.rmtree(user_data_dir, ignore_errors=True)


# =========================== UI (Tkinter) ===========================
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("UGPhone Register ‚Äî One-shot Login")
        self.geometry("1150x880")

        self.account_data = {}
        self.running_tasks = {}
        self.active_drivers = {}
        self.driver_lock = threading.Lock()
        self.stop_event_all = None
        
        self.log_q = queue.Queue()
        self.success_log_q = queue.Queue()
        self.ui_update_q = queue.Queue()

        self._create_widgets()
        self.ui_pump()

    def _create_widgets(self):
        main = ttk.Frame(self, padding=12)
        main.pack(fill="both", expand=True)
        left_col = ttk.Frame(main)
        left_col.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        right_col = ttk.Frame(main)
        right_col.grid(row=0, column=1, sticky="nsew")

        self._create_account_list_widgets(left_col)
        self._create_settings_widgets(left_col)
        self._create_export_widgets(left_col)
        self._create_proxy_widgets(right_col)
        self._create_log_widgets(right_col)
        
        bottom_row = ttk.Frame(main)
        bottom_row.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(10, 0))
        self._create_control_widgets(bottom_row)

        main.grid_rowconfigure(0, weight=1)
        main.grid_columnconfigure(0, weight=1)
        main.grid_columnconfigure(1, weight=1)
        
    def _create_account_list_widgets(self, parent):
        main_account_frame = ttk.Frame(parent)
        main_account_frame.pack(fill="both", expand=True)

        input_frame = ttk.LabelFrame(main_account_frame, text="Nh·∫≠p d·ªØ li·ªáu (email|pass)", padding=5)
        input_frame.pack(fill="x", side="top", pady=(0, 5))
        self.account_input_txt = scrolledtext.ScrolledText(input_frame, height=5)
        self.account_input_txt.pack(fill="x", expand=True, side="left", padx=(0,5))
        load_btn = ttk.Button(input_frame, text="N·∫°p v√†o\ndanh s√°ch", command=self.populate_tree_from_input)
        load_btn.pack(fill="y", expand=True, side="right")
        
        account_frame = ttk.LabelFrame(main_account_frame, text="Danh s√°ch T√†i kho·∫£n", padding=10)
        account_frame.pack(fill="both", expand=True)
        
        cols = ("#", "email", "status", "action")
        self.tree = ttk.Treeview(account_frame, columns=cols, show="headings", height=8)
        self.tree.heading("#", text="#"); self.tree.heading("email", text="Email")
        self.tree.heading("status", text="Tr·∫°ng th√°i"); self.tree.heading("action", text="H√†nh ƒë·ªông")
        self.tree.column("#", width=40, anchor="center"); self.tree.column("email", width=220)
        self.tree.column("status", width=100, anchor="center"); self.tree.column("action", width=80, anchor="center")

        vsb = ttk.Scrollbar(account_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.pack(side="right", fill="y")
        self.tree.pack(side="left", fill="both", expand=True)

        account_actions_frame = ttk.Frame(parent)
        account_actions_frame.pack(fill="x", pady=(4, 0))
        ttk.Button(account_actions_frame, text="N·∫°p t·ª´ File...", command=self.load_account_file).pack(side="left")
        ttk.Button(account_actions_frame, text="L∆∞u ra File...", command=self.save_account_list).pack(side="left", padx=5)
        ttk.Button(account_actions_frame, text="Th√™m d√≤ng...", command=self.add_account_dialog).pack(side="left", padx=5)
        self.mark_success_btn = ttk.Button(account_actions_frame, text="Chuy·ªÉn th√†nh c√¥ng", command=self.mark_selected_as_successful)
        self.mark_success_btn.pack(side="right")
        ttk.Button(account_actions_frame, text="X√≥a d√≤ng ch·ªçn", command=self.remove_selected_account).pack(side="right", padx=5)
        
        self.tree.bind("<Button-1>", self.on_tree_click)

    def _create_settings_widgets(self, parent):
        settings_frame = ttk.LabelFrame(parent, text="C√†i ƒë·∫∑t", padding=10)
        settings_frame.pack(fill="x", pady=(10,0))
        
        ttk.Label(settings_frame, text="S·ªë lu·ªìng song song:").grid(row=0, column=0, sticky="w", pady=2)
        self.threads_var = tk.StringVar(value="3")
        ttk.Spinbox(settings_frame, from_=1, to=100, textvariable=self.threads_var, width=8).grid(row=0, column=1, sticky="w")

        ttk.Label(settings_frame, text="C·ª° c·ª≠a s·ªï (W√óH):").grid(row=1, column=0, sticky="w", pady=2)
        win_size_frame = ttk.Frame(settings_frame)
        win_size_frame.grid(row=1, column=1, sticky="w")
        self.win_w_var = tk.StringVar(value="900"); self.win_h_var = tk.StringVar(value="620")
        ttk.Entry(win_size_frame, textvariable=self.win_w_var, width=8).pack(side="left")
        ttk.Entry(win_size_frame, textvariable=self.win_h_var, width=8).pack(side="left", padx=(6,0))

        ttk.Label(settings_frame, text="Grid margin X/Y:").grid(row=2, column=0, sticky="w", pady=2)
        margin_frame = ttk.Frame(settings_frame); margin_frame.grid(row=2, column=1, sticky="w")
        self.margin_x_var = tk.StringVar(value="0"); self.margin_y_var = tk.StringVar(value="0")
        ttk.Entry(margin_frame, textvariable=self.margin_x_var, width=8).pack(side="left")
        ttk.Entry(margin_frame, textvariable=self.margin_y_var, width=8).pack(side="left", padx=(6,0))

        self.ip_check_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(settings_frame, text="M·ªü ipx.ac tr∆∞·ªõc khi ƒëƒÉng k√Ω (m·ªói l·∫ßn th·ª≠)", variable=self.ip_check_var).grid(row=3, column=0, columnspan=2, sticky="w", pady=(6,0))
        self.headless_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(settings_frame, text="Ch·∫°y ng·∫ßm (headless)", variable=self.headless_var).grid(row=4, column=0, columnspan=2, sticky="w", pady=(6,0))

    def _create_export_widgets(self, parent):
        export_frame = ttk.LabelFrame(parent, text="L∆∞u localStorage (.txt)", padding=10)
        export_frame.pack(fill="x", pady=(10, 0))
        self.export_ls_var = tk.BooleanVar(value=True)
        self.export_dir_var = tk.StringVar(value=os.path.join(os.getcwd(), "localstorage_exports"))
        ttk.Checkbutton(export_frame, text="B·∫≠t l∆∞u localStorage n·∫øu t√¨m th·∫•y session", variable=self.export_ls_var).grid(row=0, column=0, sticky="w", columnspan=3)
        ttk.Label(export_frame, text="Th∆∞ m·ª•c l∆∞u:").grid(row=1, column=0, sticky="w", pady=6)
        ttk.Entry(export_frame, textvariable=self.export_dir_var, width=45).grid(row=1, column=1, sticky="w")
        def pick_dir():
            d = filedialog.askdirectory()
            if d: self.export_dir_var.set(d)
        ttk.Button(export_frame, text="Ch·ªçn...", command=pick_dir).grid(row=1, column=2, padx=(6, 0), sticky="w")

    def _create_proxy_widgets(self, parent):
        proxy_frame = ttk.LabelFrame(parent, text="C·∫•u h√¨nh Proxy", padding=10); proxy_frame.pack(fill="x")
        self.proxy_mode_var = tk.StringVar(value="none")
        ttk.Radiobutton(proxy_frame, text="Kh√¥ng s·ª≠ d·ª•ng Proxy", variable=self.proxy_mode_var, value="none").pack(anchor="w")
        ttk.Radiobutton(proxy_frame, text="D√πng 1 proxy duy nh·∫•t cho t·∫•t c·∫£", variable=self.proxy_mode_var, value="single").pack(anchor="w")
        ttk.Radiobutton(proxy_frame, text="D√πng danh s√°ch proxy ri√™ng", variable=self.proxy_mode_var, value="list").pack(anchor="w")

        self.single_proxy_entry_var = tk.StringVar()
        self.single_proxy_entry = ttk.Entry(proxy_frame, textvariable=self.single_proxy_entry_var, width=60)
        self.proxy_list_container = ttk.Frame(proxy_frame)
        self.proxy_list_txt = scrolledtext.ScrolledText(self.proxy_list_container, width=35, height=5)
        self.reset_list_txt = scrolledtext.ScrolledText(self.proxy_list_container, width=35, height=5)
        self.auto_threads_var = tk.BooleanVar(value=False)
        self.auto_threads_cb = ttk.Checkbutton(proxy_frame, text="S·ªë lu·ªìng = s·ªë proxy (auto)", variable=self.auto_threads_var)
        self.reset_frame = ttk.LabelFrame(parent, text="T·ª± ƒë·ªông Reset IP (qua API)", padding=10)
        self.single_reset_url_var = tk.StringVar(value="")
        self.single_reset_url_entry = ttk.Entry(self.reset_frame, textvariable=self.single_reset_url_var, width=60)
        self.reset_delay_var = tk.StringVar(value="10")
        self.reset_delay_spinbox = ttk.Spinbox(self.reset_frame, from_=0, to=300, textvariable=self.reset_delay_var, width=8)

        self.proxy_mode_var.trace_add("write", self.update_proxy_ui)
        self.proxy_list_txt.insert("1.0", "host1:port1:user1:pass1\nhost2:port2:user2:pass2")
        self.reset_list_txt.insert("1.0", "http://reset.url/1\nhttp://reset.url/2")
        self.update_proxy_ui()

    def _create_log_widgets(self, parent):
        log_frame = ttk.LabelFrame(parent, text="Log Thao T√°c", padding=10)
        log_frame.pack(fill="both", expand=True, pady=(10,0))
        self.log_box = scrolledtext.ScrolledText(log_frame, width=50, height=8, state="disabled")
        self.log_box.pack(fill="both", expand=True)

        success_log_frame = ttk.LabelFrame(parent, text="T√†i Kho·∫£n Th√†nh C√¥ng (ƒë√£ x√°c nh·∫≠n)", padding=10)
        success_log_frame.pack(fill="both", expand=True, pady=(10,0))
        self.success_log_box = scrolledtext.ScrolledText(success_log_frame, width=50, height=5, state="disabled")
        self.success_log_box.pack(fill="both", expand=True)
    
    def _create_control_widgets(self, parent):
        btns = ttk.Frame(parent)
        btns.pack(fill="x")
        self.start_btn = ttk.Button(btns, text="Ch·∫°y m·ª•c ch∆∞a ho√†n t·∫•t", command=self.on_start)
        self.start_btn.pack(side="left")
        self.stop_btn  = ttk.Button(btns, text="D·ª´ng t·∫•t c·∫£", command=self.on_stop, state="disabled")
        self.stop_btn.pack(side="left", padx=(10, 0))
        ttk.Button(btns, text="Tho√°t", command=self.destroy).pack(side="right")

        hint = ("L∆∞u √Ω:\n"
            "- 'Ch·∫°y m·ª•c ch∆∞a ho√†n t·∫•t' s·∫Ω b·ªè qua c√°c t√†i kho·∫£n ƒë√£ ·ªü tr·∫°ng th√°i 'Th√†nh c√¥ng'.\n"
            "- Sau khi m·ªôt t√†i kho·∫£n 'Ho√†n t·∫•t', ch·ªçn n√≥ v√† nh·∫•n 'Chuy·ªÉn th√†nh c√¥ng' ƒë·ªÉ x√°c nh·∫≠n.\n"
            f"- Cooldown reset proxy l√† {PROXY_RESET_COOLDOWN}s + ƒë·ªám {PROXY_POST_RESET_BUFFER}s.")
        ttk.Label(parent, text=hint, foreground="#555").pack(fill="x", pady=(6,0))

    def update_proxy_ui(self, *_):
        for w in [self.single_proxy_entry, self.proxy_list_container, self.auto_threads_cb, self.reset_frame]: w.pack_forget()
        for w in self.reset_frame.winfo_children(): w.grid_forget()
        mode = self.proxy_mode_var.get()
        if mode != "none":
            self.reset_frame.pack(fill="x", pady=(10,0))
        if mode == "single":
            self.single_proxy_entry.pack(fill="x", pady=(6,0))
            ttk.Label(self.reset_frame, text="Link API Reset (proxy chung):").grid(row=0, column=0, sticky="w")
            self.single_reset_url_entry.grid(row=1, column=0, columnspan=2, sticky="ew")
            ttk.Label(self.reset_frame, text="Gi√¢y ch·ªù t·ªëi thi·ªÉu khi API y√™u c·∫ßu ch·ªù:").grid(row=2, column=0, sticky="w", pady=(6,0))
            self.reset_delay_spinbox.grid(row=2, column=1, sticky="w", pady=(6,0))
        elif mode == "list":
            self.proxy_list_container.pack(fill="x", pady=(6,0))
            ttk.Label(self.proxy_list_container, text="Danh s√°ch Proxy (1 d√≤ng / proxy)").grid(row=0, column=0, sticky="w")
            self.proxy_list_txt.grid(row=1, column=0, sticky="nsew", padx=(0,6))
            ttk.Label(self.proxy_list_container, text="Link Reset API (t∆∞∆°ng ·ª©ng m·ªói d√≤ng)").grid(row=0, column=1, sticky="w")
            self.reset_list_txt.grid(row=1, column=1, sticky="nsew")
            self.proxy_list_container.grid_columnconfigure(0, weight=1); self.proxy_list_container.grid_columnconfigure(1, weight=1)
            self.auto_threads_cb.pack(anchor="w", pady=(6,0))
            ttk.Label(self.reset_frame, text="Gi√¢y ch·ªù t·ªëi thi·ªÉu khi API y√™u c·∫ßu ch·ªù:").grid(row=2, column=0, sticky="w", pady=(6,0))
            self.reset_delay_spinbox.grid(row=2, column=1, sticky="w", pady=(6,0))

    def add_account_row(self, email, password, status="S·∫µn s√†ng"):
        count = len(self.tree.get_children()) + 1
        # FIX: Ensure all values are strings for Treeview
        values_tuple = (str(count), str(email), str(status), "Ch·∫°y")
        item_id = self.tree.insert("", "end", values=values_tuple)
        self.account_data[item_id] = {"email": email, "pass": password}
        self.tree.yview_moveto(1)

    def add_account_dialog(self):
        data = simpledialog.askstring("Th√™m t√†i kho·∫£n", "Nh·∫≠p email|pass:", parent=self)
        if data and '|' in data:
            try:
                email, password = parse_email_pass(data)
                self.add_account_row(email, password)
            except ValueError as e: messagebox.showerror("L·ªói", str(e))

    def remove_selected_account(self):
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showinfo("Ch∆∞a ch·ªçn", "Vui l√≤ng ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu d√≤ng ƒë·ªÉ x√≥a.")
            return
        if messagebox.askyesno("X√°c nh·∫≠n x√≥a", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a {len(selected_items)} d√≤ng ƒë√£ ch·ªçn?"):
            for item_id in selected_items:
                if item_id in self.account_data: del self.account_data[item_id]
                self.stop_single_job(item_id, silent=True)
                self.tree.delete(item_id)
            self.renumber_tree()

    def renumber_tree(self):
        for i, item_id in enumerate(self.tree.get_children()):
            # FIX: Ensure value is a string
            self.tree.set(item_id, column="#", value=str(i + 1))
            
    def save_account_list(self):
        if not self.account_data:
            messagebox.showwarning("Danh s√°ch r·ªóng", "Kh√¥ng c√≥ g√¨ ƒë·ªÉ l∆∞u.")
            return
        filepath = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")], title="L∆∞u danh s√°ch t√†i kho·∫£n")
        if filepath:
            try:
                with open(filepath, "w", encoding="utf-8") as f:
                    for item_id in self.tree.get_children():
                        data = self.account_data.get(item_id)
                        if data and data["email"]: f.write(f"{data['email']}|{data['pass']}\n")
                self.log_fn(f"ƒê√£ l∆∞u danh s√°ch v√†o: {filepath}")
            except Exception as e: messagebox.showerror("L·ªói L∆∞u File", f"Kh√¥ng th·ªÉ l∆∞u file:\n{e}")
    
    def populate_tree_from_input(self):
        content = self.account_input_txt.get("1.0", "end-1c")
        lines = content.strip().splitlines()
        if not lines:
            messagebox.showinfo("Th√¥ng b√°o", "√î nh·∫≠p li·ªáu r·ªóng.")
            return
        if messagebox.askyesno("X√°c nh·∫≠n", "Thao t√°c n√†y s·∫Ω x√≥a danh s√°ch hi·ªán t·∫°i v√† n·∫°p d·ªØ li·ªáu m·ªõi. Ti·∫øp t·ª•c?"):
            self.tree.delete(*self.tree.get_children())
            self.account_data.clear()
            for line in lines:
                line = line.strip()
                if '|' in line:
                    try:
                        email, password = parse_email_pass(line)
                        self.add_account_row(email, password)
                    except ValueError: self.log_fn(f"B·ªè qua d√≤ng l·ªói ƒë·ªãnh d·∫°ng: {line}")
            self.log_fn(f"ƒê√£ n·∫°p {len(self.tree.get_children())} t√†i kho·∫£n v√†o danh s√°ch.")

    def load_account_file(self):
        filepath = filedialog.askopenfilename(filetypes=[("Text Files", "*.txt")], title="N·∫°p danh s√°ch t√†i kho·∫£n t·ª´ File")
        if filepath:
            try:
                with open(filepath, "r", encoding="utf-8") as f: content = f.read()
                self.account_input_txt.delete("1.0", "end")
                self.account_input_txt.insert("1.0", content)
                self.log_fn(f"ƒê√£ n·∫°p d·ªØ li·ªáu t·ª´ file v√†o √¥ nh·∫≠p li·ªáu: {filepath}")
                self.populate_tree_from_input()
            except Exception as e: messagebox.showerror("L·ªói N·∫°p File", f"Kh√¥ng th·ªÉ ƒë·ªçc file:\n{e}")

    def on_tree_click(self, event):
        if self.tree.identify_region(event.x, event.y) != "cell": return
        item_id = self.tree.identify_row(event.y)
        column_id = self.tree.identify_column(event.x)
        if column_id == "#4": # Column "action"
            current_action = self.tree.set(item_id, "action")
            if current_action == "Ch·∫°y": self.start_single_job(item_id)
            elif current_action == "ƒê√≥ng": self.stop_single_job(item_id)

    def mark_selected_as_successful(self):
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showinfo("Ch∆∞a ch·ªçn", "Vui l√≤ng ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu t√†i kho·∫£n ƒë·ªÉ chuy·ªÉn sang th√†nh c√¥ng.")
            return
        for item_id in selected_items:
            if self.tree.exists(item_id):
                self.tree.set(item_id, "status", "Th√†nh c√¥ng")
                account = self.account_data.get(item_id)
                if account: self.success_log_push(account["email"])

    def ui_pump(self):
        try:
            while True:
                line = self.log_q.get_nowait()
                self.log_box.configure(state="normal"); self.log_box.insert("end", line + "\n"); self.log_box.see("end"); self.log_box.configure(state="disabled")
        except queue.Empty: pass
        try:
            while True:
                line = self.success_log_q.get_nowait()
                self.success_log_box.configure(state="normal"); self.success_log_box.insert("end", line + "\n"); self.success_log_box.see("end"); self.success_log_box.configure(state="disabled")
        except queue.Empty: pass
        try:
            while True:
                msg_type, item_id, value = self.ui_update_q.get_nowait()
                if self.tree.exists(item_id):
                    if msg_type == "status":
                        self.tree.set(item_id, "status", value)
                        if value not in ["ƒêang ch·∫°y...", "ƒêang ch·ªù...", "ƒêang m·ªü"]:
                            if item_id in self.running_tasks: del self.running_tasks[item_id]
                            self.tree.set(item_id, "action", "Ch·∫°y")
                    elif msg_type == "action": self.tree.set(item_id, "action", value)
        except queue.Empty: pass
        self.after(100, self.ui_pump)

    def log_fn(self, msg: str): self.log_q.put(msg)
    def success_log_push(self, msg: str): self.success_log_q.put(msg)

    def _prepare_run(self):
        try:
            settings = {"n_threads": int(self.threads_var.get().strip()), "win_w": max(400, int(self.win_w_var.get().strip())),
                "win_h": max(300, int(self.win_h_var.get().strip())), "margin_x": max(0, int(self.margin_x_var.get().strip())),
                "margin_y": max(0, int(self.margin_y_var.get().strip())), "min_reset_delay": int(self.reset_delay_var.get().strip()),
                "export_ls_enabled": bool(self.export_ls_var.get()), "export_dir": self.export_dir_var.get().strip(),
                "proxy_mode": self.proxy_mode_var.get(), "headless": self.headless_var.get(), "ip_check": self.ip_check_var.get()}
        except ValueError:
            messagebox.showerror("Sai ƒë·ªãnh d·∫°ng s·ªë", "Ki·ªÉm tra l·∫°i c√°c gi√° tr·ªã s·ªë trong c√†i ƒë·∫∑t."); return None
        if settings["n_threads"] <= 0:
            messagebox.showerror("Sai s·ªë lu·ªìng", "S·ªë lu·ªìng ph·∫£i l·ªõn h∆°n 0."); return None
        settings["proxy_lines"] = []; settings["reset_url_lines"] = []
        if settings["proxy_mode"] == 'single':
            single_proxy = self.single_proxy_entry_var.get().strip()
            if not single_proxy: messagebox.showerror("Thi·∫øu Proxy", "B·∫°n ƒë√£ ch·ªçn d√πng 1 proxy nh∆∞ng ch∆∞a nh·∫≠p."); return None
            settings["proxy_lines"] = [single_proxy]; settings["reset_url_lines"] = [self.single_reset_url_var.get().strip()]
        elif settings["proxy_mode"] == 'list':
            settings["proxy_lines"] = [ln.strip() for ln in self.proxy_list_txt.get("1.0", "end").strip().splitlines() if ln.strip()]
            if not settings["proxy_lines"]: messagebox.showerror("Thi·∫øu Proxy", "B·∫°n ƒë√£ ch·ªçn d√πng danh s√°ch proxy nh∆∞ng ch∆∞a nh·∫≠p."); return None
            settings["reset_url_lines"] = [ln.strip() for ln in self.reset_list_txt.get("1.0", "end").strip().splitlines() if ln.strip()]
            if len(settings["proxy_lines"]) != len(settings["reset_url_lines"]) and settings["reset_url_lines"]:
                messagebox.showerror("L·ªói s·ªë l∆∞·ª£ng", f"S·ªë l∆∞·ª£ng proxy ({len(settings['proxy_lines'])}) ph·∫£i b·∫±ng s·ªë l∆∞·ª£ng link reset ({len(settings['reset_url_lines'])})."); return None
            if self.auto_threads_var.get():
                settings["n_threads"] = len(settings["proxy_lines"]); self.log_fn(f"INFO: T·ª± ƒë·ªông ƒë·∫∑t s·ªë lu·ªìng = {settings['n_threads']}"); self.threads_var.set(str(settings["n_threads"]))
        return settings
    
    def start_single_job(self, item_id, idx=0):
        if item_id in self.running_tasks:
            self.log_fn(f"T√†i kho·∫£n {self.account_data[item_id]['email']} ƒë√£ ƒëang ch·∫°y."); return
        settings = self._prepare_run()
        if not settings: return
        account = self.account_data[item_id]
        ep_line = f"{account['email']}|{account['pass']}"
        proxy_line = ""; reset_url = ""
        try: current_idx = self.tree.get_children().index(item_id)
        except ValueError: current_idx = idx
        if settings["proxy_mode"] != 'none' and settings["proxy_lines"]:
            proxy_line = settings["proxy_lines"][current_idx % len(settings["proxy_lines"])]
        if settings["proxy_mode"] != 'none' and settings["reset_url_lines"]:
            reset_url = settings["reset_url_lines"][current_idx % len(settings["reset_url_lines"])]
        stop_event = threading.Event()
        args = (ep_line, proxy_line, settings["ip_check"], settings["win_w"], settings["win_h"], 50, 50, current_idx,
            reset_url, settings["min_reset_delay"], self.log_fn, False, stop_event,
            settings["export_ls_enabled"], settings["export_dir"], self.ui_update_q, item_id,
            self.active_drivers, self.driver_lock)
        thread = threading.Thread(target=run_flow_single, args=args, daemon=True)
        self.running_tasks[item_id] = {"thread": thread, "stop_event": stop_event}
        self.ui_update_q.put(("status", item_id, "ƒêang ch·∫°y...")); self.ui_update_q.put(("action", item_id, "ƒê√≥ng"))
        thread.start()

    def _quit_driver_thread(self, driver):
        try:
            driver.quit()
        except Exception as e:
            self.log_fn(f"L·ªói khi bu·ªôc ƒë√≥ng tr√¨nh duy·ªát: {e}")

    def stop_single_job(self, item_id, silent=False):
        task = self.running_tasks.get(item_id)
        if task:
            if not silent:
                self.log_fn(f"ƒêang g·ª≠i y√™u c·∫ßu d·ª´ng cho {self.account_data[item_id]['email']}...")
            task["stop_event"].set()

            with self.driver_lock:
                driver_to_quit = self.active_drivers.pop(item_id, None)

            if driver_to_quit:
                if not silent:
                    self.log_fn(f"Bu·ªôc ƒë√≥ng tr√¨nh duy·ªát c·ªßa {self.account_data[item_id]['email']}.")
                threading.Thread(target=self._quit_driver_thread, args=(driver_to_quit,), daemon=True).start()
        
    def on_start(self, accounts_to_run=None):
        settings = self._prepare_run()
        if not settings: return
        if accounts_to_run is None:
            accounts_to_run = [item for item in self.tree.get_children() if self.tree.set(item, "status") not in ["Th√†nh c√¥ng", "ƒêang ch·∫°y...", "ƒêang ch·ªù...", "ƒêang m·ªü"]]
        if not accounts_to_run:
            messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ t√†i kho·∫£n n√†o h·ª£p l·ªá ƒë·ªÉ ch·∫°y."); return
        self.stop_event_all = threading.Event()
        self.start_btn.config(state="disabled"); self.stop_btn.config(state="normal")
        self.log_box.config(state="normal"); self.log_box.delete("1.0", "end"); self.log_box.config(state="disabled")
        self.success_log_box.config(state="normal"); self.success_log_box.delete("1.0", "end"); self.success_log_box.config(state="disabled")
        screen_w = self.winfo_screenwidth()
        cols = max(1, screen_w // (settings["win_w"] + settings["margin_x"]))
        self.log_fn(f"== B·∫ÆT ƒê·∫¶U: {len(accounts_to_run)} t√†i kho·∫£n, {settings['n_threads']} lu·ªìng ==")

        def run_pool():
            try:
                with concurrent.futures.ThreadPoolExecutor(max_workers=settings["n_threads"]) as ex:
                    futures = {}
                    all_items = self.tree.get_children()
                    for item_id in accounts_to_run:
                        if self.stop_event_all.is_set(): break
                        try: idx = all_items.index(item_id)
                        except ValueError: continue
                        account = self.account_data[item_id]
                        ep_line = f"{account['email']}|{account['pass']}"
                        col, row = idx % cols, idx // cols
                        pos_x, pos_y = col * (settings["win_w"] + settings["margin_x"]), row * (settings["win_h"] + settings["margin_y"])
                        proxy_line = ""; reset_url = ""
                        if settings["proxy_mode"] != 'none' and settings["proxy_lines"]:
                             proxy_line = settings["proxy_lines"][idx % len(settings["proxy_lines"])]
                        if settings["proxy_mode"] != 'none' and settings["reset_url_lines"]:
                             reset_url = settings["reset_url_lines"][idx % len(settings["reset_url_lines"])]
                        self.ui_update_q.put(("status", item_id, "ƒêang ch·ªù...")); self.ui_update_q.put(("action", item_id, "ƒê√≥ng"))
                        future = ex.submit(run_flow_single, ep_line, proxy_line, settings["ip_check"], settings["win_w"], settings["win_h"], pos_x, pos_y, idx,
                            reset_url, settings["min_reset_delay"], self.log_fn, settings["headless"], self.stop_event_all,
                            settings["export_ls_enabled"], settings["export_dir"], self.ui_update_q, item_id,
                            self.active_drivers, self.driver_lock)
                        futures[future] = item_id
                    for future in concurrent.futures.as_completed(futures):
                        item_id = futures[future]
                        try: future.result()
                        except Exception as exc:
                           self.log_fn(f"T√†i kho·∫£n {item_id} t·∫°o ra l·ªói: {exc}"); self.ui_update_q.put(("status", item_id, "L·ªói Thread"))
                self.log_fn("‚úÖ‚úÖ‚úÖ HO√ÄN TH√ÄNH T·∫§T C·∫¢.")
            finally:
                self.start_btn.config(state="normal"); self.stop_btn.config(state="disabled")
        threading.Thread(target=run_pool, daemon=True).start()

    def on_stop(self):
        if self.stop_event_all:
            self.log_fn("üõë D·ª´ng t·∫•t c·∫£‚Ä¶ C√°c lu·ªìng s·∫Ω k·∫øt th√∫c sau khi ho√†n t·∫•t phi√™n hi·ªán t·∫°i.")
            self.stop_event_all.set()
        
        # Also iterate and stop all individual running tasks immediately
        tasks_to_stop = list(self.running_tasks.keys())
        for item_id in tasks_to_stop:
            self.stop_single_job(item_id, silent=True) # Silent to avoid spamming logs

        self.stop_btn.config(state="disabled")

if __name__ == "__main__":
    app = App()
    app.mainloop()
